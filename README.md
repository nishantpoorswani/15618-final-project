# Multi-Core Cache Simulator

## SUMMARY:

We are going to implement an event-driven multi-core cache simulator. This simulator will support different snooping based cache coherence schemes. It will analyze memory accesses at run time and report various cache performance metrics. This simulator based tool will also provide cache performance optimization recommendations to the user to improve memory performance.

## BACKGROUND:

This project is an inspiration from Introduction to Computer Systems (15-213) Cache lab which is a trace-driven cache simulator for a uniprocessor. Our idea is to build an event-driven cache simulator that supports multi-core processor. Caches play a vital role in determining the performance of parallel programs on a multi-core processor. One of the major challenges that multi-core processors face is the coherency problem. Cache is coherent when all the loads and stores to a given memory location behave correctly. There are two main methods to ensure cache coherence: a) snooping based cache coherence schemes b) directory based cache coherence schemes. 

Snooping based cache coherence scheme work based on the idea that coherence-related activity is broadcast to all processors in the system. Cache controllers snoop on the bus to monitor memory operations, and react accordingly, to maintain cache coherence. There are a few snooping based cache coherence schemes like MI(VI), MSI, MESI and MOESI. 

### MI:

![image](https://user-images.githubusercontent.com/80713159/159839944-505bf792-c69b-4556-ac90-35a748906504.png)

### MSI

![tempsnip](https://user-images.githubusercontent.com/80713159/159840351-fe896d5c-6f04-4c65-b93e-15dc999fee7e.png)

### MESI

![tempsnip1](https://user-images.githubusercontent.com/80713159/159840596-00ec5f54-2cdf-4fae-b2b4-d2395418cc56.png)


## CHALLENGE:

1) Understand Pin tool to generate memory events in order and to indicate when the deired funcitons are called
2) Designing an event-driven cache simulator
3) Veifying the correctness of implemented snooping based cache coherency schemes

## RESOURCES:

1) We will be writing the event-driven cache simulator from scratch. We will be referencing the lecture slides for the various snooping based cache coherence schemes 
2) For generating memory events we will be using Intel's Pin Tool [Documentation](https://www.intel.com/content/www/us/en/developer/articles/tool/pin-a-dynamic-binary-instrumentation-tool.html)

## GOALS AND DELIVERABLES:

| Goal % | Goals |
| ----------- | ----------- |
| 75% | Implementing event-driven uni-processor cache simulator |
| 100% | Implementing MI (VI) and MSI snooping based cache coherence protocols | 
| 125% | Implementing MESI and visulization of stats and custom recommendations on how to improve memory performance | 

## PLATFORM CHOICE:

1) Programming Language:

We will be implementing the simulator in C++. Since, we are implementing multiple cache coherency protocols, we can use various aspects of Object Oriented Programming to our advantage.

2) Architecture:

Our simulator is designed to simulate programs that run on x86-64 machines.

3) Tools:

To generate the memory events, we will be using Intel's Pin tool. This tool generates memory events at run time. 

## SCHEDULE:

| Dates | Tasks |
| ----------- | ----------- |
| 03/28/22 - 04/03/22 | Understanding Pin tool and generating memory traces using Pin Tool |
| 04/04/22 - 04/06/22 | Designing event-driven uni-processor cache simulator | 
| 04/07/22 - 04/11/22 | Implementing an event-driven uni-processor cache simulator |
| 04/14/22 - 04/18/22 | Implement shared bus and brainstorm ideas to implement snooping based cache coherence protocols  |
| 04/19/22 - 04/24/22 | Implement MI and MSI snooping based cache coherence protocols  | 
| 04/25/22 - 04/29/22 | Testing and debugging of the project and bug fixes | 

## MILESTONE

**1) In one to two paragraphs, summarize the work that you have completed so far. (This should be easy if you have been maintaining this information on your project page.)**

For any cache simulator we require the memory access patterns for our desired program. We initially planned to build a trace-driven cache simulator with traces generated by Pin tool. However after speaking with Prof. Beckmann we realised that going forward an event-driven simulator would resolve the future memory access ordering problems for a multi-core processor. To do so, we needed to understand how Pin tool works along with it's APIs. After figuring this out, we were able to get the memory access patterns at run time for a given program binary. Hence, we were successfully able to generate events at every memory access for a given program.

We designed a uniprocessor cache simulator using C++ STL library and implemented it. To implement a LRU policy, cache lines are implemented using lists, the recently used cache line is pushed back and the least recently used cache line is at the front of the list. The LRU line is erased whenever there is a need for an eviction. This was thoroughly tested by using the trace files used in Cache Lab(15213 - Introduction to Computer Systems). 

The next challenge was to build a event-driven cache simulator by integrating Pin tool with our uni-processor cache simulator. Whenever, Pin tracks a memory access event, it triggers our cache simulator which simulates the cache at run time. We also create a trace of these memory accesses which we use to verify the correctness of our event-driven cache simulator. We check the cache stats obtained by running a simple program and then feed the trace obtained to the csim-ref that was used in Cache Lab (15213 - Introduction to Computer Systems). Our results match with the Csim-ref and hence, our event-driven uniprocessor cache simulator is working correctly.

**2) Describe how you are doing with respect to the goals and deliverables stated in your proposal. Do you still believe you will be able to produce all your deliverables? In your milestone writeup we want an updated list of goals that you plan to hit for the poster session.**

We are definitely on track to complete the 100% goal that we had set out. We made an update in our goals after talking to Prof. Beckmann which was to have an event-driven cache instead of a trace-driven cache. We have already achieved this goal for the milestone report. Rest of the goals remain the same. 

**3) What do you plan to show at the poster session? Will it be a demo? Will it be a graph?**

We plan to show cache statistics graphs on how different parallel programs perform with different snooping based cache coherence protocols. If time permits we plan to show a quick demo of our event-driven multi-core cache simulator.  

**4) Do you have preliminary results at this time? If so, it would be great to included them in your milestone write-up.**

We're attaching a screenshot of the stats obtained from our event-driven simulator and the reference simulator given in Cache Lab for a simple program.

**Reference cache simulator statistics**
![tempsnip](https://user-images.githubusercontent.com/80713159/162835134-8598c7e3-b094-421e-82a4-71ab321dcf4a.png)

**Event-driven cache simulator statistics**
![image](https://user-images.githubusercontent.com/80713159/162835109-0c559427-6aac-45cd-a064-159523f69d0a.png)


**5) List the issues that concern you the most. Are there any remaining unknowns (things you simply don’t know how to solve, or resource you don’t know how to get) or is it just a matter of coding and doing the work?**

Once we implement the different snooping-based cache coherence protocols, there is a challenge to verify the correctness of these protocols. Since, it's event driven we still need to think of the best possible way to verify the correctness. 

## MILESTONE 2

**Update since Milestone 1:**
1) Implemented MI, MSI, MESI snooping based cache coherence protocols. 
2) Integrated the above protocols to our event-driven cache simulator.
3) Integrated graphical visualisation to compare per thread misses/hits/evictions

**Pending tasks:**
1) Compare different snooping protocols on the same parallel program
2) Provide cache statistics for specific functions

**Ideas to further the project**
1) Provide cache coherent traffic statistics 


## AUTHORS:

Nishant Poorswani [npoorswa@andrew.cmu.edu](npoorswa@andrew.cmu.edu)

Shridhar Ganiger [sganiger@andrew.cmu.edu](sganiger@andrew.cmu.edu)
